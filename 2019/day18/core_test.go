package day18

import (
	"fmt"
	"testing"
)

func TestStepsToKey(t *testing.T) {
	tests := []struct {
		input string
		key   string
		steps int
	}{
		{`#########
#b.A.@.a#
#########`, "a", 2},
		{`#########
#b.A.@.a#
#########`, "b", -1},
		{`#########
#b.....@#
#########`, "b", 6},
		{`#########
#b.....@#
#########`, "a", -1},

		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "a", 2},
		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "b", -1},
		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "f", -1},
		{`########################
#f.D.E.e.C.b.....@.B.c.#
######################.#
#d.....................#
########################`, "b", 6},

		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "a", 2},
		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "b", 22},
		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "g", -1},

		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "b", 3},
		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "c", 5},
		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "j", -1},

		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, "a", 15},
		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, "d", 3},
	}

	for i, x := range tests {
		tt := x
		t.Run(fmt.Sprintf("test %v", i), func(t *testing.T) {
			m, err := NewMap(tt.input)
			if err != nil {
				t.Fatalf("unable to create map: %v", err)
			}
			steps := m.stepsToKey("@", tt.key)
			if steps != tt.steps {
				t.Errorf("wrong number of steps to key %#v, expected %v got %v", tt.key, tt.steps, steps)
			}
		})
	}
}

func TestGetableKeys(t *testing.T) {
	tests := []struct {
		input string
		out   []string
	}{
		{`#########
#b.A.@.a#
#########`, []string{"a"}},

		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, []string{"a"}},

		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, []string{"a", "b"}},

		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, []string{"a", "b", "c", "d", "e", "f", "g", "h"}},

		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, []string{"a", "c", "d", "e", "f"}},
	}

	for i, x := range tests {
		tt := x
		t.Run(fmt.Sprintf("test %v", i), func(t *testing.T) {
			m, err := NewMap(tt.input)
			if err != nil {
				t.Fatalf("unable to create map: %v", err)
			}
			out := m.getableKeys()
			if !strSlicEq(out, tt.out) {
				t.Errorf("wrong keys, expected %v got %v", tt.out, out)
			}
		})
	}
}

func TestAllKeySteps(t *testing.T) {
	tests := []struct {
		input string
		steps int
	}{
		{`#########
#b.A.@.a#
#########`, 8},
		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, 86},
		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, 132},
		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, 136},
		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, 81},
	}

	for i, x := range tests {
		tt := x
		t.Run(fmt.Sprintf("test %v", i), func(t *testing.T) {
			m, err := NewMap(tt.input)
			if err != nil {
				t.Fatalf("unable to create map: %v", err)
			}
			steps := m.SolveP1()
			if steps != tt.steps {
				t.Errorf("wrong number of steps, expected %v got %v", tt.steps, steps)
			}
		})
	}
}

func strSlicEq(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}

	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}

	return true
}
