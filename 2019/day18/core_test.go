package day18

import (
	"fmt"
	"testing"
)

func TestStepsToKey(t *testing.T) {
	tests := []struct {
		input string
		key   string
		steps int
	}{
		{`#########
#b.A.@.a#
#########`, "a", 2},
		{`#########
#b.A.@.a#
#########`, "b", -1},
		{`#########
#b.....@#
#########`, "b", 6},
		{`#########
#b.....@#
#########`, "a", -1},

		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "a", 2},
		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "b", -1},
		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "f", -1},
		{`########################
#f.D.E.e.C.b.....@.B.c.#
######################.#
#d.....................#
########################`, "b", 6},

		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "a", 2},
		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "b", 22},
		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "g", -1},

		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "b", 3},
		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "c", 5},
		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "j", -1},

		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, "a", 15},
		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, "d", 3},
	}

	for i, x := range tests {
		tt := x
		t.Run(fmt.Sprintf("test %v", i), func(t *testing.T) {
			m, err := NewMap(tt.input)
			if err != nil {
				t.Fatalf("unable to create map: %v", err)
			}
			steps := m.stepsToKey("@", tt.key)
			if steps != tt.steps {
				t.Errorf("wrong number of steps to key %#v, expected %v got %v", tt.key, tt.steps, steps)
			}
		})
	}
}

func TestKeysRequired(t *testing.T) {
	tests := []struct {
		input string
		door  string
		req   int
	}{
		{`#########
#b.A.@.a#
#########`, "A", 0},

		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, "C", 2},

		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, "E", 5},

		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, "G", 0},

		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, "B", 2},
	}

	for i, x := range tests {
		tt := x
		t.Run(fmt.Sprintf("test %v", i), func(t *testing.T) {
			m, err := NewMap(tt.input)
			if err != nil {
				t.Fatalf("unable to create map: %v", err)
			}
			req := m.keysRequiredForDoor(tt.door)
			if req != tt.req {
				t.Errorf("wrong of keys required for door %#v, expected %v got %v", tt.door, tt.req, req)
			}
		})
	}
}

func TestAllKeySteps(t *testing.T) {
	tests := []struct {
		input string
		steps int
	}{
		{`#########
#b.A.@.a#
#########`, 8},
		{`########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################`, 86},
		{`########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################`, 132},
		{`#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################`, 136},
		{`########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################`, 81},
	}

	for i, x := range tests {
		tt := x
		t.Run(fmt.Sprintf("test %v", i), func(t *testing.T) {
			m, err := NewMap(tt.input)
			if err != nil {
				t.Fatalf("unable to create map: %v", err)
			}
			steps := m.AllKeySteps()
			if steps != tt.steps {
				t.Errorf("wrong number of steps, expected %v got %v", tt.steps, steps)
			}
		})
	}
}
